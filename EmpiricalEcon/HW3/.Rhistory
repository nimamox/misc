SSR <- (t(e) %*% e)#sum of squared residuals - should be minimized
s2 <- (t(e) %*% e) / (n - k) #get the regression error (estimated variance of "eps").
#s2ols<-s2 #for Hausman test below
Vb <- s2[1, 1] * solve((t(X)) %*% X) # the estimated VCOV matrix of bols
seols = sqrt(diag(Vb)) # get the standard erros for your coefficients;
tvalols = bols / seols # get your t-values.
tt <-
data.frame(col1 = c(
"constant", "tsqft/1000",
"bedrms", "bathrms",
"garage", "view",
"distance"),
col2 = bols, col3 = seols, col4 = tvalols)
colnames(tt) <- c("variable", "estimate", "s.e.", "t")
# Chunk 14: R10
ttx <- xtable(tt, caption = "OLS output")
digits(ttx) <- 5   #decimals to be shown for each column
print(
ttx,
include.rownames = FALSE,
latex.environment = "center",
caption.placement = "top"
)
# Chunk 15: R11
l <- layout(matrix(c(1, 2, 3), 3, 1, byrow = TRUE),
widths = c(3, 1),
heights = c(1, 1))
plot(
e ~ tsqft,
main = "residual vs. total square footage",
xlab = "tsqft",
ylab = "e",
# xlim = c(-10, 10),
# ylim = c(-10, 10)
)
plot(
e ~ bedrms,
main = "residual vs. number of bedrooms",
xlab = "bedrms",
ylab = "e",
# xlim = c(-10, 10),
# ylim = c(-10, 10)
)
plot(
e ~ bathrms,
main = "residual vs. number of bathrooms",
xlab = "bathrms",
ylab = "e",
# xlim = c(-10, 10),
# ylim = c(-10, 10)
)
# Chunk 16: R12
int <- (t(e) %*% e) / n
g <- (e ^ 2 / (int[1, 1])) - 1
#capture variables you think may be related to HSK
Z <- cbind(rep(n, 1), tsqft/1000, bedrms, bathrms)
kz <- ncol(Z)
LM <- (1 / 2) * (t(g) %*% Z %*% solve(t(Z) %*% Z) %*% t(Z) %*% g)
pval = 1 - pchisq(LM, kz - 1)
# Chunk 17: R13
yaux <- e ^ 2 #use squared OLS residuals as dep.var. in White test
#construct all permissible squared terms from the original X
Xsq <- cbind(bedrms ^ 2, bathrms ^ 2, distance ^ 2)
#construct all permissible interaction terms from the original X
# first for all continuous variables
Xc1 <- tsqft/1000 * bedrms
Xc2 <- tsqft/1000 * bathrms
Xc3 <- tsqft/1000 * distance
Xc4 <- bedrms * bathrms
Xc5 <- bedrms * distance
Xc6 <- bathrms * distance
#
#next for the continuous with indicators
dmat <- cbind(garage, view)
Xcitsqft <- matrix(rep(tsqft/1000, 2), nrow = n) * dmat
Xcibedrms <- matrix(rep(bedrms, 2), nrow = n) * dmat
Xcibathrms <- matrix(rep(bathrms, 2), nrow = n) * dmat
Xcidistance <- matrix(rep(distance, 2), nrow = n) * dmat
#
#Next: Run auxiliary regression and capture R^2
Xaux <-cbind(X,
Xsq,
Xc1,
Xc2,
Xc3,
Xc4,
Xc5,
Xc6,
Xcitsqft,
Xcibedrms,
Xcibathrms,
Xcidistance)
kaux <- ncol(Xaux)
baux <- solve((t(Xaux)) %*% Xaux) %*% (t(Xaux) %*% yaux)
eaux <- yaux - Xaux %*% baux
I <- diag(n)
i <- rep(1, n)
Mo <- I - i %*% solve(t(i) %*% i) %*% t(i)
SSE <- t(eaux) %*% eaux
SST <- t(yaux) %*% Mo %*% yaux
R2 <- 1 - SSE / SST
Wh <- n * R2
pval = 1 - pchisq(Wh, kaux - 1)
# Chunk 18: R14
bols <- solve((t(X)) %*% X) %*% (t(X) %*% y)
e <- as.vector(y - X %*% bols)
S <- diag(e ^ 2)
Vb <- solve((t(X)) %*% X) %*% t(X) %*% S %*% X %*% solve((t(X)) %*% X)
se_rols = sqrt(diag(Vb))
tval = bols / se_rols
#
ttols <- data.frame(
col1 = c("constant", "tsqft/1000", "bedrms", "bathrms",
"garage", "view", "distance"),
col2 = bols,
col3 = se_rols,
col4 = tval
)
colnames(ttols) <- c("variable", "estimate", "s.e.", "t")
# Chunk 19: R15
ttx <- xtable(tt, caption = "Robust OLS output")
digits(ttx) <- 5   #decimals to be shown for each column
print(
ttx,
include.rownames = FALSE,
latex.environment = "center",
caption.placement = "top"
)
# Chunk 20: R16
#Step 1: Consistent estimate of Omega
yaux <- log(e ^ 2)
Xaux <- cbind(rep(n, 1), tsqft/1000, bedrms, bathrms)
kaux <- ncol(Xaux)
baux <- solve((t(Xaux)) %*% Xaux) %*% (t(Xaux) %*% yaux)
sigvec <- as.vector(exp(Xaux %*% baux) + 1.2704) #Harvey's suggested correction
Om <- diag(sigvec)
#
#Step 2: GLS
bgls <- solve((t(X)) %*% solve(Om) %*% X) %*% (t(X) %*% solve(Om) %*% y)
e <- y - X %*% bgls
Vb <- solve((t(X)) %*% solve(Om) %*% X)
se = sqrt(diag(Vb))
tval = bgls / se
#
ttgls <-
data.frame(
col1 = c("constant", "tsqft/1000", "bedrms", "bathrms",
"garage", "view", "distance"),
col2 = bgls,
col3 = se,
col4 = tval
)
colnames(ttgls) <- c("variable", "estimate", "s.e.", "t")
# Chunk 21: R17
ttx <- xtable(tt, caption = "FGLS output")
digits(ttx) <- 5   #decimals to be shown for each column
print(
ttx,
include.rownames = FALSE,
latex.environment = "center",
caption.placement = "top"
)
# Chunk 1: setup
library(knitr)
opts_chunk$set(fig.path='figure/theme-', cache.path='cache/theme-', cache=TRUE)
options(formatR.arrow=TRUE,width=60)
#knit_hooks$set(par=function(before, options, envir){if (before) par(mar=c(4,4,.1,.1),cex.lab=.95,cex.axis=.9,mgp=c(2,.7,0),tcl=-.3)})
# Chunk 2: denim
knit_theme$set("bclear")
# Chunk 3: R0
options(prompt = "R> ", digits = 4)
options(continue=" ")
setwd('/Users/nima/AAEC5126/HW3/')
# Chunk 4
options(continue=" ")
options(width=60)
set.seed(37)
library("xtable")
library("corpcor") #for pseudo-inverse
# Chunk 5: R1
data <- read.table('/Users/nima/AAEC5126/data/consumption.txt', sep="\t", header=FALSE)
colnames(data) <- c("year_", "quarter", "realgdp", "realcons","realinv", "realgov",
"realdpi", "cpi_u", "m1", "tbill", "unemp", "pop", "infl", "realint")
attach(data)
# Chunk 6: R2
# Define variables
n <- nrow(data)
y <- realcons[2:n]
ylag <- realcons[1:(n - 1)]
dpi <- realdpi[2:n]
cpi <- cpi_u[2:n]
dpilag <- realdpi[1:(n - 1)]
rate <- realint[2:n]
n <- length(y)  #IMPORTANT - re-define n!
#
X <- cbind(rep(1, n), dpi, cpi, rate)
k <- ncol(X)
#
bols <- solve((t(X)) %*% X) %*% (t(X) %*% y)# compute OLS estimator
e <- y - X %*% bols # Get residuals.
SSR <- (t(e) %*% e)#sum of squared residuals - should be minimized
s2 <- (t(e) %*% e) / (n - k) #get the regression error (estimated variance of "eps").
s2ols <- s2 #for Hausman test below
Vb <- s2[1, 1] * solve((t(X)) %*% X) # get the estimated VCOV matrix of bols
se_ols = sqrt(diag(Vb)) # get the standard erros for your coefficients;
tval_ols = bols / se # get your t-values.
#
tt <- data.frame(
col1 = c("constant", "dpi", "cpi", "rate"),
col2 = bols,
col3 = se_ols,
col4 = tval_ols
)
colnames(tt) <- c("variable", "estimate", "s.e.", "t")
# Chunk 7: R3
ttx <- xtable(tt, caption = "OLS output")
digits(ttx) <- 5   #decimals to be shown for each column
print(
ttx,
include.rownames = FALSE,
latex.environment = "center",
caption.placement = "top"
)
# Chunk 8: R4
# Build instrument matrix
Z <- cbind(rep(1, n), cpi, rate, dpilag, ylag)
Xhat <- Z %*% solve(t(Z) %*% Z) %*% t(Z) %*% X
k <- ncol(Xhat)  #Don't forget to update k!
#
btsls <- solve((t(Xhat)) %*% Xhat) %*% (t(Xhat) %*% y)# compute OLS estimator
e <- y - X %*% btsls # careful - don't use Xhat here!
SSR <- (t(e) %*% e) #sum of squared residuals - should be minimized
s2 <- (t(e) %*% e) / (n - k) #get the regression error (estimated variance of "eps").
Vb <- s2[1, 1] * solve((t(Xhat)) %*% Xhat) # get the estimated VCOV matrix of bols
se_tsls = sqrt(diag(Vb)) # get the standard erros for your coefficients;
tval_tsls = btsls / se # get your t-values.
#
tt <- data.frame(
col1 = c("constant", "dpi", "cpi", "rate"),
col2 = btsls,
col3 = se_tsls,
col4 = tval_tsls
)
colnames(tt) <- c("variable", "estimate", "s.e.", "t")
# Chunk 9: R5
ttx <- xtable(tt, caption = "TSLS output")
digits(ttx) <- 5   #decimals to be shown for each column
print(
ttx,
include.rownames = FALSE,
latex.environment = "center",
caption.placement = "top"
)
# Chunk 10: R6
d <- btsls - bols
W <- solve(t(Xhat) %*% Xhat) - solve(t(X) %*% X)
H <- (t(d) %*% pseudoinverse(W) %*% d) / s2ols[1, 1]   #Note use of OLS s2
J <- 1
pval = 1 - pchisq(H, J)
# Chunk 11: R7
# Step 1: regress dpi on Z and capture predicted values
dpihat <- Z %*% solve(t(Z) %*% Z) %*% t(Z) %*% dpi
# Step 2: add predicted values to original regression
X <- cbind(rep(1, n), dpi, cpi, rate, dpihat)
k <- ncol(X)
bwu <- solve((t(X)) %*% X) %*% (t(X) %*% y)# compute OLS estimator
e <- y - X %*% bwu # Get residuals.
s2 <- (t(e) %*% e) / (n - k) #get the regression error (estimated variance of "eps").
Vb <- s2[1, 1] * solve((t(X)) %*% X) # get the estimated VCOV matrix of bols
# Step 3: Perform F-test
Rmat <- matrix(c(0, 0, 0, 0, 1), nrow = 1)
q <- 0
J <- nrow(Rmat)
b <- bwu
Fstat <- (1 / J) * t(Rmat %*% b - q) %*%
solve(Rmat %*% Vb %*% t(Rmat)) %*% (Rmat %*% b - q)
pval <- 1 - pf(Fstat, J, n - k)
# Chunk 12: R8
data <- read.table('/Users/nima/AAEC5126/data/homeprice.txt', sep="\t", header=FALSE)
colnames(data) <- c("id", "price", "ln_price", "tsqft","bedrms", "bathrms", "age",
"garage", "view", "firepl", "porch", "distance", "sewer", "year")
attach(data)
# Chunk 13: R9
# Define variables
n <- nrow(data)
y <- price / 1000
X <- cbind(rep(1, n), tsqft / 1000, bedrms, bathrms, garage, view, distance)
k <- ncol(X)
bols <- solve((t(X)) %*% X) %*% (t(X) %*% y)# compute OLS estimator
e <- y - X %*% bols # Get residuals.
SSR <- (t(e) %*% e)#sum of squared residuals - should be minimized
s2 <- (t(e) %*% e) / (n - k) #get the regression error (estimated variance of "eps").
#s2ols<-s2 #for Hausman test below
Vb <- s2[1, 1] * solve((t(X)) %*% X) # the estimated VCOV matrix of bols
se_ols = sqrt(diag(Vb)) # get the standard erros for your coefficients;
tval_ols = bols / seols # get your t-values.
tt <-
data.frame(col1 = c(
"constant", "tsqft/1000",
"bedrms", "bathrms",
"garage", "view",
"distance"),
col2 = bols, col3 = se_ols, col4 = tval_ols)
colnames(tt) <- c("variable", "estimate", "s.e.", "t")
# Chunk 14: R10
ttx <- xtable(tt, caption = "OLS output")
digits(ttx) <- 5   #decimals to be shown for each column
print(
ttx,
include.rownames = FALSE,
latex.environment = "center",
caption.placement = "top"
)
# Chunk 15: R11
l <- layout(matrix(c(1, 2, 3), 3, 1, byrow = TRUE),
widths = c(3, 1),
heights = c(1, 1))
plot(
e ~ tsqft,
main = "residual vs. total square footage",
xlab = "tsqft",
ylab = "e",
# xlim = c(-10, 10),
# ylim = c(-10, 10)
)
plot(
e ~ bedrms,
main = "residual vs. number of bedrooms",
xlab = "bedrms",
ylab = "e",
# xlim = c(-10, 10),
# ylim = c(-10, 10)
)
plot(
e ~ bathrms,
main = "residual vs. number of bathrooms",
xlab = "bathrms",
ylab = "e",
# xlim = c(-10, 10),
# ylim = c(-10, 10)
)
# Chunk 16: R12
int <- (t(e) %*% e) / n
g <- (e ^ 2 / (int[1, 1])) - 1
#capture variables you think may be related to HSK
Z <- cbind(rep(n, 1), tsqft/1000, bedrms, bathrms)
kz <- ncol(Z)
LM <- (1 / 2) * (t(g) %*% Z %*% solve(t(Z) %*% Z) %*% t(Z) %*% g)
pval = 1 - pchisq(LM, kz - 1)
# Chunk 17: R13
yaux <- e ^ 2 #use squared OLS residuals as dep.var. in White test
#construct all permissible squared terms from the original X
Xsq <- cbind(bedrms ^ 2, bathrms ^ 2, distance ^ 2)
#construct all permissible interaction terms from the original X
# first for all continuous variables
Xc1 <- tsqft/1000 * bedrms
Xc2 <- tsqft/1000 * bathrms
Xc3 <- tsqft/1000 * distance
Xc4 <- bedrms * bathrms
Xc5 <- bedrms * distance
Xc6 <- bathrms * distance
#
#next for the continuous with indicators
dmat <- cbind(garage, view)
Xcitsqft <- matrix(rep(tsqft/1000, 2), nrow = n) * dmat
Xcibedrms <- matrix(rep(bedrms, 2), nrow = n) * dmat
Xcibathrms <- matrix(rep(bathrms, 2), nrow = n) * dmat
Xcidistance <- matrix(rep(distance, 2), nrow = n) * dmat
#
#Next: Run auxiliary regression and capture R^2
Xaux <-cbind(X,
Xsq,
Xc1,
Xc2,
Xc3,
Xc4,
Xc5,
Xc6,
Xcitsqft,
Xcibedrms,
Xcibathrms,
Xcidistance)
kaux <- ncol(Xaux)
baux <- solve((t(Xaux)) %*% Xaux) %*% (t(Xaux) %*% yaux)
eaux <- yaux - Xaux %*% baux
I <- diag(n)
i <- rep(1, n)
Mo <- I - i %*% solve(t(i) %*% i) %*% t(i)
SSE <- t(eaux) %*% eaux
SST <- t(yaux) %*% Mo %*% yaux
R2 <- 1 - SSE / SST
Wh <- n * R2
pval = 1 - pchisq(Wh, kaux - 1)
# Chunk 18: R14
bols <- solve((t(X)) %*% X) %*% (t(X) %*% y)
e <- as.vector(y - X %*% bols)
S <- diag(e ^ 2)
Vb <- solve((t(X)) %*% X) %*% t(X) %*% S %*% X %*% solve((t(X)) %*% X)
se_rols = sqrt(diag(Vb))
tval_rols = bols / se_rols
#
ttols <- data.frame(
col1 = c("constant", "tsqft/1000", "bedrms", "bathrms",
"garage", "view", "distance"),
col2 = bols, col3 = se_rols, col4 = tval_rols
)
colnames(ttols) <- c("variable", "estimate", "s.e.", "t")
# Chunk 19: R15
ttx <- xtable(tt, caption = "Robust OLS output")
digits(ttx) <- 5   #decimals to be shown for each column
print(
ttx,
include.rownames = FALSE,
latex.environment = "center",
caption.placement = "top"
)
# Chunk 20: R16
#Step 1: Consistent estimate of Omega
yaux <- log(e ^ 2)
Xaux <- cbind(rep(n, 1), tsqft/1000, bedrms, bathrms)
kaux <- ncol(Xaux)
baux <- solve((t(Xaux)) %*% Xaux) %*% (t(Xaux) %*% yaux)
sigvec <- as.vector(exp(Xaux %*% baux) + 1.2704) #Harvey's suggested correction
Om <- diag(sigvec)
#
#Step 2: GLS
bgls <- solve((t(X)) %*% solve(Om) %*% X) %*% (t(X) %*% solve(Om) %*% y)
e <- y - X %*% bgls
Vb <- solve((t(X)) %*% solve(Om) %*% X)
se_fgls = sqrt(diag(Vb))
tval_fgls = bgls / se
#
ttgls <-
data.frame(
col1 = c("constant", "tsqft/1000", "bedrms", "bathrms",
"garage", "view", "distance"),
col2 = bgls,
col3 = se_fgls,
col4 = tval_fgls
)
colnames(ttgls) <- c("variable", "estimate", "s.e.", "t")
# Chunk 21: R17
ttx <- xtable(ttgls, caption = "FGLS output")
digits(ttx) <- 5   #decimals to be shown for each column
print(
ttx,
include.rownames = FALSE,
latex.environment = "center",
caption.placement = "top"
)
# Chunk 22: R18
ttcompare <-
data.frame(
col1 = c("constant", "tsqft/1000", "bedrms", "bathrms",
"garage", "view", "distance"),
col2 = se_ols,
col3 = se_rols,
col4 = se_fgls,
col5 = tval_ols,
col6 = tval_rols,
col7 = tval_fgls,
)
colnames(ttcompare) <- c("variable", "s.e. (OLS)", "s.e. (rOLS)", "s.e. (FGLS)", "t (OLS)", "t (rOLS)", "t (FGLS)")
ttx <- xtable(ttgls, caption = "Comparison")
digits(ttx) <- 5   #decimals to be shown for each column
print(
ttx,
include.rownames = FALSE,
latex.environment = "center",
caption.placement = "top"
)
ttcompare <-
data.frame(
col1 = c("constant", "tsqft/1000", "bedrms", "bathrms",
"garage", "view", "distance"),
col2 = se_ols,
col3 = se_rols,
col4 = se_fgls,
col5 = tval_ols,
col6 = tval_rols,
col7 = tval_fgls,
)
colnames(ttcompare) <- c("variable", "s.e. (OLS)", "s.e. (rOLS)", "s.e. (FGLS)", "t (OLS)", "t (rOLS)", "t (FGLS)")
ttx <- xtable(ttcompare, caption = "Comparison")
digits(ttx) <- 5   #decimals to be shown for each column
print(
ttx,
include.rownames = FALSE,
latex.environment = "center",
caption.placement = "top"
)
data.frame(
col1 = c("constant", "tsqft/1000", "bedrms", "bathrms",
"garage", "view", "distance"),
col2 = se_ols,
col3 = se_rols,
col4 = se_fgls,
col5 = tval_ols,
col6 = tval_rols,
col7 = tval_fgls,
)
c("constant", "tsqft/1000", "bedrms", "bathrms",
"garage", "view", "distance")
se_ols
se_rols
se_fgls
tval_olsvvv
tval_ols
tval_rols
cc
tval_fglstval_fgls
tval_fgls
